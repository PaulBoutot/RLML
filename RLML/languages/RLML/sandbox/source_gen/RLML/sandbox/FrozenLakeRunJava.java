package RLML.sandbox;

/*Generated by MPS */

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Random;
import java.util.Arrays;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Serializable;
import java.util.Set;
import java.util.function.Function;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;

public class FrozenLakeRunJava {
  /*package*/ final DecimalFormat df = new DecimalFormat("#.##");

  /*package*/ String[] states;
  /*package*/ int statesCount;
  /*package*/ String[] doneStates;
  /*package*/ int[][] rewards;
  /*package*/ int[][] actions;
  /*package*/ int actionsCount;
  /*package*/ ArrayList<ArrayList<Integer>> rewardsArrLst = new ArrayList<ArrayList<Integer>>();
  /*package*/ ArrayList<ArrayList<Integer>> actionsArrLst = new ArrayList<ArrayList<Integer>>();
  /*package*/ double[][] qTable;

  /*package*/ ActorCriticAgent agent;
  /*package*/ Vec stateValues;

  public FrozenLakeRunJava() {
    init();
  }

  /*package*/ void init() {
    // Set parameters and environment reward matrix R
    // Remove all spaces, then remove first open brackets [, and last closed bracket ]
    String str = "[S(0;0), F(0;1), F(0;2), F(0;3), F(1;0), H(1;1), F(1;2), H(1;3), F(2;0), F(2;1), F(2;2), H(2;3), H(3;0), F(3;1), F(3;2), G(3;3)]  ".replaceAll("\\s+", "");
    str = str.substring(1, str.length() - 1);
    states = str.split(",");

    // Total possible number of states and actions
    statesCount = states.length;
    actionsCount = states.length;

    // Done states; goal state or states that will end the game
    String doneStr = "[G(3;3),H(1;1),H(1;3),H(2;3),H(3;0)] ".replaceAll("\\s+", "");
    doneStr = doneStr.substring(1, doneStr.length() - 1);
    doneStates = doneStr.split(",");

    String rewardStr = "[[0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1],  [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1],  [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1], [0, 0, 0, 0, 0, -1, 0, -1, 0, 0, 0, -1, -1, 0, 0, 1]]";
    rewards = strToArrArr(rewardStr, rewardsArrLst);
    actions = strToArrArr("[[1,4], [0,2,5], [1,3,6], [2,7],[0,5,8], [1,4,6,9], [2,5,7,10], [3,6,11], [4,9,12],[5,8,10,13],[6,9,11,14], [7,10,15], [8,13],[9,12,14],[10,13,15],[15]] ", actionsArrLst);
    //  Initialize matrix Q as zero matrix
    qTable = new double[statesCount][statesCount];
    // Initialize actor critic agent
    agent = new ActorCriticAgent(statesCount, actionsCount);
    stateValues = new Vec(statesCount);
  }

  public int[][] strToArrArr(String str, ArrayList<ArrayList<Integer>> arryLst) {
    // Remove all spaces, then remove first two open brackets [[, and last closed bracket ]
    str = str.replaceAll("\\s+", "");
    str = str.substring(2, str.length() - 1);

    // Split string based on remaining open brackets
    String[] strArr = str.split("\\[");

    for (String arr : strArr) {
      // For each string in the array, remove the closed bracket ], and the comma
      arr = arr.substring(0, arr.indexOf("]"));

      // Split each string based on comma to get the final string array
      String[] arrArr = arr.split(",");

      ArrayList<Integer> arrArrInt = new ArrayList<Integer>();
      for (int i = 0; i < arrArr.length; i++) {
        arrArrInt.add(Integer.parseInt(arrArr[i]));
      }
      arryLst.add(arrArrInt);
    }
    return arrayLstToArrArrInt(arryLst);
  }

  public int[][] arrayLstToArrArrInt(ArrayList<ArrayList<Integer>> arryLst) {
    int[][] arrArrInt = new int[arryLst.size()][];

    for (int i = 0; i < arrArrInt.length; i++) {
      arrArrInt[i] = new int[arryLst.get(i).size()];
    }

    for (int i = 0; i < arryLst.size(); i++) {
      for (int j = 0; j < arryLst.get(i).size(); j++) {
        arrArrInt[i][j] = arryLst.get(i).get(j);
      }
    }

    return arrArrInt;
  }

  public static void main(String[] args) {
    long Begin = System.currentTimeMillis();
    FrozenLakeRunJava obj = new FrozenLakeRunJava();
    obj.run();
    obj.printQTableResult();
    obj.saveQTableResult();
    obj.showPolicy();

    long End = System.currentTimeMillis();
    System.out.println("\nTime: " + (End - Begin) / 1000.0 + "sec.");
  }

  public void run() {
    {
      // SARSA : We will choose the current action At and the next action A(t+1) using the same policy.
      // And thus, in the state S(t+1), its action will be A(t+1) which is selected while updating 
      // the action-state value of St.

      final double alpha = 0.2;
      final double gamma = 0.4;
      boolean done = false;
      Random rand = new Random();

      // Train episodes
      for (int i = 0; i < 10000; i++) {

        // For each episode: select random initial state
        int state = rand.nextInt(statesCount);

        int index = rand.nextInt(actions[state].length);
        // Initial action, the rest is calculated while preparing the Q_Table
        int action = actions[state][index];

        done = false;
        // Do while not reach goal state o
        while (!(done)) {

          int nextState = action;
          int r = rewards[state][action];
          if (Arrays.asList(doneStates).contains(states[nextState])) {
            done = true;
          }

          // Using this possible action, consider to go to the next state
          double q = qTable[state][action];

          // Select one action among all possible actions for the current state
          // Selection strategy is random in this example
          // Action outcome is set to deterministic in this example
          // Transition probability is 1
          int index2 = rand.nextInt(actions[state].length);
          int nextAction = actions[state][index2];
          double q2 = qTable[nextState][nextAction];

          // SARSA Computation 
          double value = q + alpha * (r + gamma * q2 - q);
          qTable[state][action] = value;

          // Set the next state as the current state
          state = nextState;
          action = nextAction;
        }
      }
    }
  }

  /*package*/ double maxQ(int s) {
    int[] actionsFromState = actions[s];
    double maxValue = Double.MIN_VALUE;
    for (int i = 0; i < actionsFromState.length; i++) {
      int nextState = actionsFromState[i];
      double value = qTable[s][nextState];
      if (value > maxValue) {
        maxValue = value;
      }
    }
    return maxValue;
  }

  /*package*/ double Q(int s, int a) {
    return qTable[s][a];
  }

  /*package*/ void setQ(int s, int a, double value) {
    qTable[s][a] = value;
  }

  /*package*/ int R(int s, int a) {
    return rewards[s][a];
  }

  public StringBuilder getResult() {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(this.printQTableResult());
    stringBuilder.append(System.getProperty("line.separator"));
    stringBuilder.append(this.showPolicy());
    return stringBuilder;
  }

  /*package*/ void saveQTableResult() {
    try {
      File qTableFile = new File("FrozenLakeRunJava.txt");
      if (qTableFile.createNewFile()) {
        System.out.println("file created: " + qTableFile.getName());
      } else {
        System.out.println("File already exists");
      }
      FileWriter writer = new FileWriter(qTableFile);
      writer.write(getResult().toString());
      writer.close();
    } catch (IOException e) {
      System.out.println("An error occured" + e);
      e.printStackTrace();
    }
  }

  public StringBuilder printQTableResult() {
    StringBuilder qTableStr = new StringBuilder();
    qTableStr.append("Q-Table Result:");
    qTableStr.append(System.getProperty("line.separator"));

    for (int i = 0; i < qTable.length; i++) {
      qTableStr.append("" + states[i] + ":  ");
      for (int j = 0; j < qTable[i].length; j++) {
        qTableStr.append(String.format("%6s ", df.format(qTable[i][j])));
      }
      qTableStr.append(System.getProperty("line.separator"));
    }

    System.out.println(qTableStr.toString());
    return qTableStr;
  }



  /*package*/ int policy(int state) {
    int[] actionsFromState = actions[state];
    double maxValue = Double.MIN_VALUE;
    int policyGotoState = state;
    // Default go to self if not found
    for (int i = 0; i < actionsFromState.length; i++) {
      int nextState = actionsFromState[i];
      double value = qTable[state][nextState];
      if (value > maxValue) {
        maxValue = value;
        policyGotoState = nextState;
      }
    }
    return policyGotoState;
  }

  public StringBuilder showPolicy() {
    StringBuilder policy = new StringBuilder();
    policy.append("Policy:");
    policy.append(System.getProperty("line.separator"));

    for (int i = 0; i < states.length; i++) {
      int to = policy(i);
      policy.append(String.format("From %2s go to %2s", states[i], states[to]));
      policy.append(System.getProperty("line.separator"));
    }

    System.out.println(policy.toString());
    return policy;
  }


  public class ActorCriticAgent implements Serializable {
    private ActorCriticLearner learner;
    private int currentState;
    private int prevState;
    private int prevAction;
    public void enableEligibilityTrace(double lambda) {
      ActorCriticLambdaLearner acll = new ActorCriticLambdaLearner(learner);
      acll.setLambda(lambda);
      learner = acll;
    }
    public void start(int stateId) {
      currentState = stateId;
      prevAction = -1;
      prevState = -1;
    }
    public ActorCriticLearner getLearner() {
      return learner;
    }
    public void setLearner(ActorCriticLearner learner) {
      this.learner = learner;
    }
    public ActorCriticAgent(int stateCount, int actionCount) {
      learner = new ActorCriticLearner(stateCount, actionCount);
    }
    public ActorCriticAgent() {
    }
    public ActorCriticAgent(ActorCriticLearner learner) {
      this.learner = learner;
    }
    public ActorCriticAgent makeCopy() {
      ActorCriticAgent clone = new ActorCriticAgent();
      clone.copy(this);
      return clone;
    }
    public void copy(ActorCriticAgent rhs) {
      learner = (ActorCriticLearner) rhs.learner.makeCopy();
      prevAction = rhs.prevAction;
      prevState = rhs.prevState;
      currentState = rhs.currentState;
    }
    @Override
    public boolean equals(Object obj) {
      if (obj != null && obj instanceof ActorCriticAgent) {
        ActorCriticAgent rhs = (ActorCriticAgent) obj;
        return learner.equals(rhs.learner) && prevAction == rhs.prevAction && prevState == rhs.prevState && currentState == rhs.currentState;
      }
      return false;
    }
    public int selectAction(Set<Integer> actionsAtState) {
      return learner.selectAction(currentState, actionsAtState);
    }
    public int selectAction() {
      return learner.selectAction(currentState);
    }
    public void update(int actionTaken, int newState, double immediateReward, final Vec V) {
      update(actionTaken, newState, null, immediateReward, V);
    }
    public void update(int actionTaken, int newState, Set<Integer> actionsAtNewState, double immediateReward, final Vec V) {
      learner.update(currentState, actionTaken, newState, actionsAtNewState, immediateReward, new Function<Integer, Double>() {
        public Double apply(Integer stateId) {
          return V.get(stateId);
        }
      });
      prevAction = actionTaken;
      prevState = currentState;
      currentState = newState;
    }

  }

  public class ActorCriticLearner implements Serializable {
    protected QModel P;
    protected ActionSelectionStrategy actionSelectionStrategy;

    public Object makeCopy() {
      ActorCriticLearner clone = new ActorCriticLearner();
      clone.copy(this);
      return clone;
    }
    public void copy(ActorCriticLearner rhs) {
      P = rhs.P.makeCopy();
      actionSelectionStrategy = (ActionSelectionStrategy) ((AbstractActionSelectionStrategy) rhs.actionSelectionStrategy).clone();
    }
    public boolean equals(Object obj) {
      if (obj != null && obj instanceof ActorCriticLearner) {
        ActorCriticLearner rhs = (ActorCriticLearner) obj;
        return P.equals(rhs.P) && getActionSelection().equals(rhs.getActionSelection());
      }
      return false;
    }
    public ActorCriticLearner() {
    }
    public ActorCriticLearner(int stateCount, int actionCount) {
      this(stateCount, actionCount, 1, 0.7, 0.01);
    }
    public int selectAction(int stateId, Set<Integer> actionsAtState) {
      IndexValue iv = actionSelectionStrategy.selectAction(stateId, P, actionsAtState);
      return iv.getIndex();
    }
    public int selectAction(int stateId) {
      return selectAction(stateId, null);
    }
    public ActorCriticLearner(int stateCount, int actionCount, double beta, double gamma, double initialP) {
      P = new QModel(stateCount, actionCount, initialP);
      P.setAlpha(beta);
      P.setGamma(gamma);
      actionSelectionStrategy = new GibbsSoftMaxActionSelectionStrategy();
    }
    public void update(int currentStateId, int currentActionId, int newStateId, double immediateReward, Function<Integer, Double> V) {
      update(currentStateId, currentActionId, newStateId, null, immediateReward, V);
    }
    public void update(int currentStateId, int currentActionId, int newStateId, Set<Integer> actionsAtNewState, double immediateReward, Function<Integer, Double> V) {
      double td_error = immediateReward + V.apply(newStateId) - V.apply(currentStateId);
      double oldP = P.getQ(currentStateId, currentActionId);
      double beta = P.getAlpha(currentStateId, currentActionId);
      double newP = oldP + beta * td_error;
      P.setQ(currentStateId, currentActionId, newP);
    }
    public String getActionSelection() {
      return (new ActionSelectionStrategyFactory()).serialize(actionSelectionStrategy);
    }
    public void setActionSelection(String conf) {
      this.actionSelectionStrategy = (new ActionSelectionStrategyFactory()).deserialize(conf);
    }
    public QModel getP() {
      return P;
    }
    public void setP(QModel p) {
      P = p;
    }
  }

  public class ActorCriticLambdaLearner extends ActorCriticLearner {
    private Matrix e;
    private double lambda = 0.9;
    private EligibilityTraceUpdateMode traceUpdateMode = EligibilityTraceUpdateMode.ReplaceTrace;
    public ActorCriticLambdaLearner() {
      super();
    }
    public ActorCriticLambdaLearner(int stateCount, int actionCount) {
      super(stateCount, actionCount);
      e = new Matrix(stateCount, actionCount);
    }
    public ActorCriticLambdaLearner(ActorCriticLearner learner) {
      copy(learner);
      e = new Matrix(P.getStateCount(), P.getActionCount());
    }
    public ActorCriticLambdaLearner(int stateCount, int actionCount, double alpha, double gamma, double lambda, double initialP) {
      super(stateCount, actionCount, alpha, gamma, initialP);
      this.lambda = lambda;
      e = new Matrix(stateCount, actionCount);
    }
    public EligibilityTraceUpdateMode getTraceUpdateMode() {
      return traceUpdateMode;
    }
    public void setTraceUpdateMode(EligibilityTraceUpdateMode traceUpdateMode) {
      this.traceUpdateMode = traceUpdateMode;
    }
    public double getLambda() {
      return lambda;
    }
    public void setLambda(double lambda) {
      this.lambda = lambda;
    }
    public ActorCriticLambdaLearner makeCopy() {
      ActorCriticLambdaLearner clone = new ActorCriticLambdaLearner();
      clone.copy(this);
      return clone;
    }
    public void copy(ActorCriticLearner rhs) {
      super.copy(rhs);
      ActorCriticLambdaLearner rhs2 = (ActorCriticLambdaLearner) rhs;
      e = rhs2.e.makeCopy();
      lambda = rhs2.lambda;
      traceUpdateMode = rhs2.traceUpdateMode;
    }
    public boolean equals(Object obj) {
      if (!(super.equals(obj))) {
        return false;
      }
      if (obj instanceof ActorCriticLambdaLearner) {
        ActorCriticLambdaLearner rhs = (ActorCriticLambdaLearner) obj;
        return e.equals(rhs.e) && lambda == rhs.lambda && traceUpdateMode == rhs.traceUpdateMode;
      }
      return false;
    }
    public Matrix getEligibility() {
      return e;
    }
    public void setEligibility(Matrix e) {
      this.e = e;
    }
    public void update(int currentStateId, int currentActionId, int newStateId, Set<Integer> actionsAtNewState, double immediateReward, Function<Integer, Double> V) {
      double td_error = immediateReward + V.apply(newStateId) - V.apply(currentStateId);
      int stateCount = P.getStateCount();
      int actionCount = P.getActionCount();
      double gamma = P.getGamma();
      e.set(currentStateId, currentActionId, e.get(currentStateId, currentActionId) + 1);
      for (int stateId = 0; stateId < stateCount; ++stateId) {
        for (int actionId = 0; actionId < actionCount; ++actionId) {
          double oldP = P.getQ(stateId, actionId);
          double alpha = P.getAlpha(currentStateId, currentActionId);
          double newP = oldP + alpha * td_error * e.get(stateId, actionId);
          P.setQ(stateId, actionId, newP);
          if (actionId != currentActionId) {
            e.set(currentStateId, actionId, 0);
          } else {
            e.set(stateId, actionId, e.get(stateId, actionId) * gamma * lambda);
          }
        }
      }
    }
  }

  public enum EligibilityTraceUpdateMode {
    ReplaceTrace(),
    AccumulateTrace()
  }


  /*package*/ interface ActionSelectionStrategy extends Serializable {
    FrozenLakeRunJava.IndexValue selectAction(int stateId, FrozenLakeRunJava.QModel model, Set<Integer> actionsAtState);
    FrozenLakeRunJava.IndexValue selectAction(int stateId, FrozenLakeRunJava.UtilityModel model, Set<Integer> actionsAtState);
    String getPrototype();
    Map<String, String> getAttributes();
  }

  public abstract class AbstractActionSelectionStrategy implements ActionSelectionStrategy {
    private String prototype;
    protected Map<String, String> attributes = new HashMap<String, String>();
    public String getPrototype() {
      return prototype;
    }
    public IndexValue selectAction(int stateId, QModel model, Set<Integer> actionsAtState) {
      return new IndexValue();
    }
    public IndexValue selectAction(int stateId, UtilityModel model, Set<Integer> actionsAtState) {
      return new IndexValue();
    }
    public AbstractActionSelectionStrategy() {
      prototype = this.getClass().getCanonicalName();
    }
    public AbstractActionSelectionStrategy(HashMap<String, String> attributes) {
      this.attributes = attributes;
      if (attributes.containsKey("prototype")) {
        this.prototype = attributes.get("prototype");
      }
    }
    public Map<String, String> getAttributes() {
      return attributes;
    }
    @Override
    public boolean equals(Object obj) {
      ActionSelectionStrategy rhs = (ActionSelectionStrategy) obj;
      if (!(prototype.equalsIgnoreCase(rhs.getPrototype()))) {
        return false;
      }
      for (Map.Entry<String, String> entry : rhs.getAttributes().entrySet()) {
        if (!(attributes.containsKey(entry.getKey()))) {
          return false;
        }
        if (!(attributes.get(entry.getKey()).equals(entry.getValue()))) {
          return false;
        }
      }
      for (Map.Entry<String, String> entry : attributes.entrySet()) {
        if (!(rhs.getAttributes().containsKey(entry.getKey()))) {
          return false;
        }
        if (!(rhs.getAttributes().get(entry.getKey()).equals(entry.getValue()))) {
          return false;
        }
      }
      return true;
    }
    @Override
    public abstract Object clone();
  }

  public class ActionSelectionStrategyFactory {
    public ActionSelectionStrategy deserialize(String conf) {
      String[] comps = conf.split(";");
      HashMap<String, String> attributes = new HashMap<String, String>();
      for (int i = 0; i < comps.length; ++i) {
        String comp = comps[i];
        String[] field = comp.split("=");
        if (field.length < 2) {
          continue;
        }
        String fieldname = field[0].trim();
        String fieldvalue = field[1].trim();
        attributes.put(fieldname, fieldvalue);
      }
      if (attributes.isEmpty()) {
        attributes.put("prototype", conf);
      }
      String prototype = attributes.get("prototype");
      if (prototype.equals(GreedyActionSelectionStrategy.class.getCanonicalName())) {
        return new GreedyActionSelectionStrategy();
      } else
      if (prototype.equals(SoftMaxActionSelectionStrategy.class.getCanonicalName())) {
        return new SoftMaxActionSelectionStrategy();
      } else
      if (prototype.equals(EpsilonGreedyActionSelectionStrategy.class.getCanonicalName())) {
        return new EpsilonGreedyActionSelectionStrategy(attributes);
      } else
      if (prototype.equals(GibbsSoftMaxActionSelectionStrategy.class.getCanonicalName())) {
        return new GibbsSoftMaxActionSelectionStrategy();
      }
      return null;
    }
    public String serialize(ActionSelectionStrategy strategy) {
      Map<String, String> attributes = strategy.getAttributes();
      attributes.put("prototype", strategy.getPrototype());
      StringBuilder sb = new StringBuilder();
      boolean first = true;
      for (Map.Entry<String, String> entry : attributes.entrySet()) {
        if (first) {
          first = false;
        } else {
          sb.append(";");
        }
        sb.append(entry.getKey() + "=" + entry.getValue());
      }
      return sb.toString();
    }
  }

  public class EpsilonGreedyActionSelectionStrategy extends AbstractActionSelectionStrategy {
    public static final String EPSILON = "epsilon";
    private Random random = new Random();
    @Override
    public Object clone() {
      EpsilonGreedyActionSelectionStrategy clone = new EpsilonGreedyActionSelectionStrategy();
      clone.copy(this);
      return clone;
    }
    public void copy(EpsilonGreedyActionSelectionStrategy rhs) {
      random = rhs.random;
      for (Map.Entry<String, String> entry : rhs.attributes.entrySet()) {
        attributes.put(entry.getKey(), entry.getValue());
      }
    }
    @Override
    public boolean equals(Object obj) {
      if (obj != null && obj instanceof EpsilonGreedyActionSelectionStrategy) {
        EpsilonGreedyActionSelectionStrategy rhs = (EpsilonGreedyActionSelectionStrategy) obj;
        if (epsilon() != rhs.epsilon()) {
          return false;
        }
        return true;
      }
      return false;
    }
    private double epsilon() {
      return Double.parseDouble(attributes.get(EPSILON));
    }
    public EpsilonGreedyActionSelectionStrategy() {
      epsilon(0.1);
    }
    public EpsilonGreedyActionSelectionStrategy(HashMap<String, String> attributes) {
      super(attributes);
    }
    private void epsilon(double value) {
      attributes.put(EPSILON, "" + value);
    }
    public EpsilonGreedyActionSelectionStrategy(Random random) {
      this.random = random;
      epsilon(0.1);
    }
    @Override
    public IndexValue selectAction(int stateId, QModel model, Set<Integer> actionsAtState) {
      if (random.nextDouble() < 1 - epsilon()) {
        return model.actionWithMaxQAtState(stateId, actionsAtState);
      } else {
        int actionId;
        if (actionsAtState != null && !(actionsAtState.isEmpty())) {
          ArrayList<Integer> actions = new ArrayList<Integer>(actionsAtState);
          actionId = actions.get(random.nextInt(actions.size()));
        } else {
          actionId = random.nextInt(model.getActionCount());
        }
        double Q = model.getQ(stateId, actionId);
        return new IndexValue(actionId, Q);
      }
    }
  }

  public class GibbsSoftMaxActionSelectionStrategy extends AbstractActionSelectionStrategy {
    private Random random = null;
    public GibbsSoftMaxActionSelectionStrategy() {
      random = new Random();
    }
    public GibbsSoftMaxActionSelectionStrategy(Random random) {
      this.random = random;
    }
    @Override
    public Object clone() {
      GibbsSoftMaxActionSelectionStrategy clone = new GibbsSoftMaxActionSelectionStrategy();
      return clone;
    }
    @Override
    public IndexValue selectAction(int stateId, QModel model, Set<Integer> actionsAtState) {
      ArrayList<Integer> actions = new ArrayList<Integer>();
      if (actionsAtState == null) {
        for (int i = 0; i < model.getActionCount(); ++i) {
          actions.add(i);
        }
      } else {
        for (Integer actionId : actionsAtState) {
          actions.add(actionId);
        }
      }
      double sum = 0;
      ArrayList<Double> plist = new ArrayList<Double>();
      for (int i = 0; i < actions.size(); ++i) {
        int actionId = actions.get(i);
        double p = Math.exp(model.getQ(stateId, actionId));
        sum += p;
        plist.add(sum);
      }
      IndexValue iv = new IndexValue();
      iv.setIndex(-1);
      iv.setValue(Double.NEGATIVE_INFINITY);
      double r = sum * random.nextDouble();
      for (int i = 0; i < actions.size(); ++i) {
        if (plist.get(i) >= r) {
          int actionId = actions.get(i);
          iv.setValue(model.getQ(stateId, actionId));
          iv.setIndex(actionId);
          break;
        }
      }
      return iv;
    }
  }

  public class GreedyActionSelectionStrategy extends AbstractActionSelectionStrategy {
    @Override
    public IndexValue selectAction(int stateId, QModel model, Set<Integer> actionsAtState) {
      return model.actionWithMaxQAtState(stateId, actionsAtState);
    }
    @Override
    public Object clone() {
      GreedyActionSelectionStrategy clone = new GreedyActionSelectionStrategy();
      return clone;
    }
    @Override
    public boolean equals(Object obj) {
      return obj != null && obj instanceof GreedyActionSelectionStrategy;
    }
  }

  public class SoftMaxActionSelectionStrategy extends AbstractActionSelectionStrategy {
    private Random random = new Random();
    @Override
    public Object clone() {
      SoftMaxActionSelectionStrategy clone = new SoftMaxActionSelectionStrategy(random);
      return clone;
    }
    @Override
    public boolean equals(Object obj) {
      return obj != null && obj instanceof SoftMaxActionSelectionStrategy;
    }
    public SoftMaxActionSelectionStrategy() {
    }
    public SoftMaxActionSelectionStrategy(Random random) {
      this.random = random;
    }
    @Override
    public IndexValue selectAction(int stateId, QModel model, Set<Integer> actionsAtState) {
      return model.actionWithSoftMaxQAtState(stateId, actionsAtState, random);
    }
  }


  public class UtilityModel implements Serializable {
    private Vec U;
    private int stateCount;
    private int actionCount;

    public void setU(Vec U) {
      this.U = U;
    }

    public Vec getU() {
      return U;
    }

    public double getU(int stateId) {
      return U.get(stateId);
    }

    public int getStateCount() {
      return stateCount;
    }

    public int getActionCount() {
      return actionCount;
    }

    public UtilityModel(int stateCount, int actionCount, double initialU) {
      this.stateCount = stateCount;
      this.actionCount = actionCount;
      U = new Vec(stateCount);
      U.setAll(initialU);
    }
    public UtilityModel(int stateCount, int actionCount) {
      this(stateCount, actionCount, 0.1);
    }
    public UtilityModel() {
    }
    public void copy(UtilityModel rhs) {
      U = (rhs.U == null ? null : rhs.U.makeCopy());
      actionCount = rhs.actionCount;
      stateCount = rhs.stateCount;
    }
    public UtilityModel makeCopy() {
      UtilityModel clone = new UtilityModel();
      clone.copy(this);
      return clone;
    }
    public boolean equals(Object rhs) {
      if (rhs != null && rhs instanceof UtilityModel) {
        UtilityModel rhs2 = (UtilityModel) rhs;
        if (actionCount != rhs2.actionCount || stateCount != rhs2.stateCount) {
          return false;
        }
        if ((U == null && rhs2.U != null) && (U != null && rhs2.U == null)) {
          return false;
        }
        return !(U != null && !(U.equals(rhs2.U)));
      }
      return false;
    }
    public void reset(double initialU) {
      U.setAll(initialU);
    }

  }

  public class Vec {
    private Map<Integer, Double> data = new HashMap<>();
    private int dimension;
    private double defaultValue;
    private int id = -1;

    public Vec() {
    }

    public Vec(double[] v) {
      for (int i = 0; i < v.length; ++i) {
        set(i, v[i]);
      }
    }

    public Vec(int dimension) {
      this.dimension = dimension;
      defaultValue = 0;
    }

    public Vec(int dimension, Map<Integer, Double> data) {
      this.dimension = dimension;
      defaultValue = 0;
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        set(entry.getKey(), entry.getValue());
      }
    }

    public Map<Integer, Double> getData() {
      return data;
    }

    public void set(int i, double value) {
      if (value == defaultValue) {
        return;
      }
      data.put(i, value);
      if (i >= dimension) {
        dimension = i + 1;
      }
    }

    public int getDimension() {
      return dimension;
    }

    public double getDefaultValue() {
      return defaultValue;
    }

    public int getId() {
      return this.id;
    }

    public void setId(int id) {
      this.id = id;
    }

    public double get(int i) {
      return data.getOrDefault(i, defaultValue);
    }

    public void setAll(double value) {
      defaultValue = value;
      for (Integer index : data.keySet()) {
        data.put(index, defaultValue);
      }
    }

    public IndexValue indexWithMaxValue(Set<Integer> indices) {
      if (indices == null) {
        return indexWithMaxValue();
      } else {
        IndexValue iv = new IndexValue();
        iv.setIndex(-1);
        iv.setValue(Double.NEGATIVE_INFINITY);
        for (Integer index : indices) {
          double value = data.getOrDefault(index, Double.NEGATIVE_INFINITY);
          if (value > iv.getValue()) {
            iv.setIndex(index);
            iv.setValue(value);
          }
        }
        return iv;
      }
    }

    public IndexValue indexWithMaxValue() {
      IndexValue iv = new IndexValue();
      iv.setIndex(-1);
      iv.setValue(Double.NEGATIVE_INFINITY);
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        if (entry.getKey() >= dimension) {
          continue;
        }
        double value = entry.getValue();
        if (value > iv.getValue()) {
          iv.setValue(value);
          iv.setIndex(entry.getKey());
        }
      }
      if (!(iv.isValid())) {
        iv.setValue(defaultValue);
      } else {
        if (iv.getValue() < defaultValue) {
          for (int i = 0; i < dimension; ++i) {
            if (!(data.containsKey(i))) {
              iv.setValue(defaultValue);
              iv.setIndex(i);
              break;
            }
          }
        }
      }
      return iv;
    }

    public Vec projectOrthogonal(Iterable<Vec> vlist) {
      Vec b = this;
      for (Vec v : vlist) {
        b = b.minus(b.projectAlong(v));
      }
      return b;
    }

    public Vec projectOrthogonal(ArrayList<Vec> vlist, Map<Integer, Double> alpha) {
      Vec b = this;
      for (int i = 0; i < vlist.size(); ++i) {
        Vec v = vlist.get(i);
        double norm_a = v.multiply(v);
        if ((new DoubleUtils()).isZero(norm_a)) {
          return new Vec(dimension);
        }
        double sigma = multiply(v) / norm_a;
        Vec v_parallel = v.multiply(sigma);
        alpha.put(i, sigma);
        b = b.minus(v_parallel);
      }
      return b;
    }

    public Vec projectAlong(Vec rhs) {
      double norm_a = rhs.multiply(rhs);
      if ((new DoubleUtils()).isZero(norm_a)) {
        return new Vec(dimension);
      }
      double sigma = multiply(rhs) / norm_a;
      return rhs.multiply(sigma);
    }

    public Vec multiply(double rhs) {
      Vec clone = (Vec) this.makeCopy();
      for (Integer i : data.keySet()) {
        clone.data.put(i, rhs * data.get(i));
      }
      return clone;
    }

    public double multiply(Vec rhs) {
      double productSum = 0;
      if (defaultValue == 0) {
        for (Map.Entry<Integer, Double> entry : data.entrySet()) {
          productSum += entry.getValue() * rhs.get(entry.getKey());
        }
      } else {
        for (int i = 0; i < dimension; ++i) {
          productSum += get(i) * rhs.get(i);
        }
      }
      return productSum;
    }

    public Vec pow(double scalar) {
      Vec result = new Vec(dimension);
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        result.data.put(entry.getKey(), Math.pow(entry.getValue(), scalar));
      }
      return result;
    }

    public Vec add(Vec rhs) {
      Vec result = new Vec(dimension);
      int index;
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        index = entry.getKey();
        result.data.put(index, entry.getValue() + rhs.data.get(index));
      }
      for (Map.Entry<Integer, Double> entry : rhs.data.entrySet()) {
        index = entry.getKey();
        if (result.data.containsKey(index)) {
          continue;
        }
        result.data.put(index, entry.getValue() + data.get(index));
      }
      return result;
    }

    public Vec minus(Vec rhs) {
      Vec result = new Vec(dimension);
      int index;
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        index = entry.getKey();
        result.data.put(index, entry.getValue() - rhs.data.get(index));
      }
      for (Map.Entry<Integer, Double> entry : rhs.data.entrySet()) {
        index = entry.getKey();
        if (result.data.containsKey(index)) {
          continue;
        }
        result.data.put(index, data.get(index) - entry.getValue());
      }
      return result;
    }

    public double sum() {
      double sum = 0;
      for (Map.Entry<Integer, Double> entry : data.entrySet()) {
        sum += entry.getValue();
      }
      sum += defaultValue * (dimension - data.size());
      return sum;
    }

    public boolean isZero() {
      return (new DoubleUtils()).isZero(sum());
    }

    public double norm(int level) {
      if (level == 1) {
        double sum = 0;
        for (Double val : data.values()) {
          sum += Math.abs(val);
        }
        if (!((new DoubleUtils()).isZero(defaultValue))) {
          sum += Math.abs(defaultValue) * (dimension - data.size());
        }
        return sum;
      } else
      if (level == 2) {
        double sum = multiply(this);
        if (!((new DoubleUtils()).isZero(defaultValue))) {
          sum += (dimension - data.size()) * (defaultValue * defaultValue);
        }
        return Math.sqrt(sum);
      } else {
        double sum = 0;
        for (Double val : this.data.values()) {
          sum += Math.pow(Math.abs(val), level);
        }
        if (!((new DoubleUtils()).isZero(defaultValue))) {
          sum += Math.pow(Math.abs(defaultValue), level) * (dimension - data.size());
        }
        return Math.pow(sum, 1.0 / level);
      }
    }

    public Vec normalize() {
      double norm = norm(2);
      // L2 norm is the cartesian distance
      if ((new DoubleUtils()).isZero(norm)) {
        return new Vec(dimension);
      }
      Vec clone = new Vec(dimension);
      clone.setAll(defaultValue / norm);
      for (Integer k : data.keySet()) {
        clone.data.put(k, data.get(k) / norm);
      }
      return clone;
    }

    public Vec makeCopy() {
      Vec clone = new Vec(dimension);
      clone.copy(this);
      return clone;
    }

    public void copy(Vec rhs) {
      defaultValue = rhs.defaultValue;
      dimension = rhs.dimension;
      id = rhs.id;
      data.clear();
      for (Map.Entry<Integer, Double> entry : rhs.data.entrySet()) {
        data.put(entry.getKey(), entry.getValue());
      }
    }

    @Override
    public boolean equals(Object rhs) {
      if (rhs != null && rhs instanceof Vec) {
        Vec rhs2 = (Vec) rhs;
        if (dimension != rhs2.dimension) {
          return false;
        }
        if (data.size() != rhs2.data.size()) {
          return false;
        }
        for (Integer index : data.keySet()) {
          if (!(rhs2.data.containsKey(index))) {
            return false;
          }
          if (!((new DoubleUtils()).equals(data.get(index), rhs2.data.get(index)))) {
            return false;
          }
        }
        if (defaultValue != rhs2.defaultValue) {
          for (int i = 0; i < dimension; ++i) {
            if (data.containsKey(i)) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    }


  }

  public class IndexValue {
    private int index;
    private double value;

    public IndexValue() {
    }

    public IndexValue(int index, double value) {
      this.index = index;
      this.value = value;
    }

    public boolean isValid() {
      return index != -1;
    }

    public int getIndex() {
      return index;
    }

    public void setIndex(int index) {
      this.index = index;
    }

    public double getValue() {
      return value;
    }

    public void setValue(double value) {
      this.value = value;
    }
  }

  public class Matrix {
    private Map<Integer, Vec> rows = new HashMap<>();
    private int rowCount;
    private int columnCount;
    private double defaultValue;

    public Matrix() {
    }

    public Map<Integer, Vec> getRows() {
      return rows;
    }

    public int getRowCount() {
      return rowCount;
    }

    public void setRowCount(int rowCount) {
      this.rowCount = rowCount;
    }

    public int getColumnCount() {
      return columnCount;
    }

    public double getDefaultValue() {
      return defaultValue;
    }

    public Matrix(double[][] A) {
      for (int i = 0; i < A.length; ++i) {
        double[] B = A[i];
        for (int j = 0; j < B.length; ++j) {
          set(i, j, B[j]);
        }
      }
    }

    public void setRow(int rowIndex, Vec rowVector) {
      rowVector.setId(rowIndex);
      rows.put(rowIndex, rowVector);
    }

    public Matrix identity(int dimension) {
      Matrix m = new Matrix(dimension, dimension);
      for (int i = 0; i < m.getRowCount(); ++i) {
        m.set(i, i, 1);
      }
      return m;
    }

    public Matrix makeCopy() {
      Matrix clone = new Matrix(rowCount, columnCount);
      clone.copy(this);
      return clone;
    }

    public void copy(Matrix rhs) {
      rowCount = rhs.rowCount;
      columnCount = rhs.columnCount;
      defaultValue = rhs.defaultValue;
      rows.clear();
      for (Map.Entry<Integer, Vec> entry : rhs.rows.entrySet()) {
        rows.put(entry.getKey(), entry.getValue().makeCopy());
      }
    }

    public void set(int rowIndex, int columnIndex, double value) {
      Vec row = rowAt(rowIndex);
      row.set(columnIndex, value);
      if (rowIndex >= rowCount) {
        rowCount = rowIndex + 1;
      }
      if (columnIndex >= columnCount) {
        columnCount = columnIndex + 1;
      }
    }

    public Matrix(int rowCount, int columnCount) {
      this.rowCount = rowCount;
      this.columnCount = columnCount;
      this.defaultValue = 0;
    }

    public Vec rowAt(int rowIndex) {
      Vec row = rows.get(rowIndex);
      if (row == null) {
        row = new Vec(columnCount);
        row.setAll(defaultValue);
        row.setId(rowIndex);
        rows.put(rowIndex, row);
      }
      return row;
    }

    public void setAll(double value) {
      defaultValue = value;
      for (Vec row : rows.values()) {
        row.setAll(value);
      }
    }

    public double get(int rowIndex, int columnIndex) {
      Vec row = rowAt(rowIndex);
      return row.get(columnIndex);
    }

    public ArrayList<Vec> columnVectors() {
      Matrix A = this;
      int n = A.getColumnCount();
      int rowCount = A.getRowCount();
      ArrayList<Vec> Acols = new ArrayList<Vec>();
      for (int c = 0; c < n; ++c) {
        Vec Acol = new Vec(rowCount);
        Acol.setAll(defaultValue);
        Acol.setId(c);
        for (int r = 0; r < rowCount; ++r) {
          Acol.set(r, A.get(r, c));
        }
        Acols.add(Acol);
      }
      return Acols;
    }

    public Matrix multiply(Matrix rhs) {
      if (this.getColumnCount() != rhs.getRowCount()) {
        System.err.println("A.columnCount must be equal to B.rowCount in multiplication");
        return null;
      }
      Vec row1;
      Vec col2;
      Matrix result = new Matrix(getRowCount(), rhs.getColumnCount());
      result.setAll(defaultValue);
      ArrayList<Vec> rhsColumns = rhs.columnVectors();
      for (Map.Entry<Integer, Vec> entry : rows.entrySet()) {
        int r1 = entry.getKey();
        row1 = entry.getValue();
        for (int c2 = 0; c2 < rhsColumns.size(); ++c2) {
          col2 = rhsColumns.get(c2);
          result.set(r1, c2, row1.multiply(col2));
        }
      }
      return result;
    }

    public boolean isSymmetric() {
      if (getRowCount() != getColumnCount()) {
        return false;
      }
      for (Map.Entry<Integer, Vec> rowEntry : rows.entrySet()) {
        int row = rowEntry.getKey();
        Vec rowVec = rowEntry.getValue();
        for (Integer col : rowVec.getData().keySet()) {
          if (row == col.intValue()) {
            continue;
          }
          if ((new DoubleUtils()).equals(rowVec.get(col), this.get(col, row))) {
            return false;
          }
        }
      }
      return true;
    }

    public Vec multiply(Vec rhs) {
      if (this.getColumnCount() != rhs.getDimension()) {
        System.err.println("columnCount must be equal to the size of the vector for multiplication");
      }
      Vec row1;
      Vec result = new Vec(getRowCount());
      for (Map.Entry<Integer, Vec> entry : rows.entrySet()) {
        row1 = entry.getValue();
        result.set(entry.getKey(), row1.multiply(rhs));
      }
      return result;
    }

    @Override
    public boolean equals(Object rhs) {
      if (rhs != null && rhs instanceof Matrix) {
        Matrix rhs2 = (Matrix) rhs;
        if (rowCount != rhs2.rowCount || columnCount != rhs2.columnCount) {
          return false;
        }
        if (defaultValue == rhs2.defaultValue) {
          for (Integer index : rows.keySet()) {
            if (!(rhs2.rows.containsKey(index))) {
              return false;
            }
            if (!(rows.get(index).equals(rhs2.rows.get(index)))) {
              System.out.println("failed!");
              return false;
            }
          }
          for (Integer index : rhs2.rows.keySet()) {
            if (!(rows.containsKey(index))) {
              return false;
            }
            if (!(rhs2.rows.get(index).equals(rows.get(index)))) {
              System.out.println("failed! 22");
              return false;
            }
          }
        } else {
          for (int i = 0; i < rowCount; ++i) {
            for (int j = 0; j < columnCount; ++j) {
              if (this.get(i, j) != rhs2.get(i, j)) {
                return false;
              }
            }
          }
        }
        return true;
      }
      return false;
    }

  }

  public class QModel {
    private Matrix Q;
    private Matrix alphaMatrix;
    private double gamma;
    private int stateCount;
    private int actionCount;

    public QModel() {
    }

    public QModel(int stateCount, int actionCount) {
      this(stateCount, actionCount, 0.1);
    }

    public QModel(int stateCount, int actionCount, double initialQ) {
      this.stateCount = stateCount;
      this.actionCount = actionCount;
      Q = new Matrix(stateCount, actionCount);
      alphaMatrix = new Matrix(stateCount, actionCount);
      Q.setAll(initialQ);
      alphaMatrix.setAll(0.1);
    }

    public int getStateCount() {
      return stateCount;
    }

    public int getActionCount() {
      return actionCount;
    }

    public double getGamma() {
      return gamma;
    }

    public void setGamma(double gamma) {
      this.gamma = gamma;
    }

    public boolean equals(Object rhs) {
      if (rhs != null && rhs instanceof QModel) {
        QModel rhs2 = (QModel) rhs;
        if (gamma != rhs2.gamma) {
          return false;
        }
        if (stateCount != rhs2.stateCount || actionCount != rhs2.actionCount) {
          return false;
        }
        if ((Q != null && rhs2.Q == null) || (Q == null && rhs2.Q != null)) {
          return false;
        }
        if ((alphaMatrix != null && rhs2.alphaMatrix == null) || (alphaMatrix == null && rhs2.alphaMatrix != null)) {
          return false;
        }
        return !((Q != null && !(Q.equals(rhs2.Q))) || (alphaMatrix != null && !(alphaMatrix.equals(rhs2.alphaMatrix))));
      }
      return false;
    }
    public QModel makeCopy() {
      QModel clone = new QModel();
      clone.copy(this);
      return clone;
    }
    public void copy(QModel rhs) {
      gamma = rhs.gamma;
      stateCount = rhs.stateCount;
      actionCount = rhs.actionCount;
      Q = (rhs.Q == null ? null : rhs.Q.makeCopy());
      alphaMatrix = (rhs.alphaMatrix == null ? null : rhs.alphaMatrix.makeCopy());
    }
    public double getQ(int stateId, int actionId) {
      return Q.get(stateId, actionId);
    }
    public void setQ(int stateId, int actionId, double Qij) {
      Q.set(stateId, actionId, Qij);
    }
    public double getAlpha(int stateId, int actionId) {
      return alphaMatrix.get(stateId, actionId);
    }
    public void setAlpha(double defaultAlpha) {
      this.alphaMatrix.setAll(defaultAlpha);
    }
    public IndexValue actionWithMaxQAtState(int stateId, Set<Integer> actionsAtState) {
      Vec rowVector = Q.rowAt(stateId);
      return rowVector.indexWithMaxValue(actionsAtState);
    }
    private void reset(double initialQ) {
      Q.setAll(initialQ);
    }
    public IndexValue actionWithSoftMaxQAtState(int stateId, Set<Integer> actionsAtState, Random random) {
      Vec rowVector = Q.rowAt(stateId);
      double sum = 0;
      if (actionsAtState == null) {
        actionsAtState = new HashSet<>();
        for (int i = 0; i < actionCount; ++i) {
          actionsAtState.add(i);
        }
      }
      ArrayList<Integer> actions = new ArrayList<>();
      for (Integer actionId : actionsAtState) {
        actions.add(actionId);
      }
      double[] acc = new double[actions.size()];
      for (int i = 0; i < actions.size(); ++i) {
        sum += rowVector.get(actions.get(i));
        acc[i] = sum;
      }
      double r = random.nextDouble() * sum;
      IndexValue result = new IndexValue();
      for (int i = 0; i < actions.size(); ++i) {
        if (acc[i] >= r) {
          int actionId = actions.get(i);
          result.setIndex(actionId);
          result.setValue(rowVector.get(actionId));
          break;
        }
      }
      return result;
    }

  }

  public class DoubleUtils {
    public boolean equals(double a1, double a2) {
      return Math.abs(a1 - a2) < 1.0E-10;
    }
    public boolean isZero(double a) {
      return a < 1.0E-20;
    }
  }
}
